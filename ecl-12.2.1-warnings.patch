--- ./src/h/ecl-inl.h.orig	2012-02-04 16:02:28.000000000 -0700
+++ ./src/h/ecl-inl.h	2012-02-04 21:28:54.727337118 -0700
@@ -73,11 +73,11 @@
                 cl_fixnum padding[(sizeof(struct ecl_base_string)+3)/4*4]; \
         } name[]
 
-#define ecl_def_string_array_elt(chars) {                      \
+#define ecl_def_string_array_elt(chars) { {                     \
                 (int8_t)t_base_string, 0, aet_bc, 0,            \
                         Cnil, (cl_index)(sizeof(chars))-1,      \
                         (cl_index)(sizeof(chars))-1,            \
-                        (ecl_base_char*)(chars) }
+                        (ecl_base_char*)(chars) } }
 
 #define ecl_def_ct_base_string(name,chars,len,static,const)     \
         static const struct ecl_base_string name ## _data = {    \
--- ./src/h/internal.h.orig	2012-02-04 16:02:28.000000000 -0700
+++ ./src/h/internal.h	2012-02-04 21:28:54.728337098 -0700
@@ -201,7 +201,6 @@
         frame->frame.env = env;                                         \
         frame->frame.size = narg;                                       \
         if (narg < C_ARGUMENTS_LIMIT) {                                 \
-                cl_index i;                                             \
                 cl_object *p = frame->frame.base = env->values;         \
                 va_list args;                                           \
                 va_start(args, lastarg);                                \
--- ./src/c/num_rand.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/num_rand.d	2012-02-04 21:28:54.728337098 -0700
@@ -21,6 +21,7 @@
 #include <stdlib.h>
 #include <ecl/internal.h>
 #include <fcntl.h>
+#include <unistd.h>
 #if !defined(_MSC_VER) && !defined(__MINGW32__)
 # include <sys/stat.h>
 /* it isn't pulled in by fcntl.h */
--- ./src/c/num_arith.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/num_arith.d	2012-02-04 21:28:54.729337077 -0700
@@ -67,7 +67,6 @@
 cl_object
 ecl_gcd(cl_object x, cl_object y)
 {
-	cl_object gcd;
         ECL_WITH_TEMP_BIGNUM(x_big,1);
         ECL_WITH_TEMP_BIGNUM(y_big,1);
 
--- ./src/c/instance.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/instance.d	2012-02-04 21:28:54.729337077 -0700
@@ -90,9 +90,11 @@
 
 	if (ecl_unlikely(!ECL_INSTANCEP(x)))
                 FEwrong_type_nth_arg(@[si::instance-ref], 1, x, @[ext::instance]);
-	if (ecl_unlikely(!FIXNUMP(index) ||
-                         (i = fix(index)) < 0 || i >= (cl_fixnum)x->instance.length))
-	        FEtype_error_index(x, index);
+	if (ecl_unlikely(!FIXNUMP(index)))
+		FEwrong_type_nth_arg(@[si::instance-ref], 2, index, @[fixnum]);
+	i = fix(index);
+	if (ecl_unlikely(i < 0 || i >= (cl_fixnum)x->instance.length))
+	        FEtype_error_index(x, i);
 	@(return x->instance.slots[i])
 }
 
@@ -103,9 +105,11 @@
 
 	if (ecl_unlikely(!ECL_INSTANCEP(x)))
                 FEwrong_type_nth_arg(@[si::instance-ref], 1, x, @[ext::instance]);
-	if (ecl_unlikely(!FIXNUMP(index) ||
-                         (i = fix(index)) < 0 || i >= x->instance.length))
-	        FEtype_error_index(x, index);
+	if (ecl_unlikely(!FIXNUMP(index)))
+		FEwrong_type_nth_arg(@[si::instance-ref], 2, index, @[fixnum]);
+	i = fix(index);
+	if (ecl_unlikely(i < 0 || i >= (cl_fixnum)x->instance.length))
+	        FEtype_error_index(x, i);
 	x = x->instance.slots[i];
 	if (ecl_unlikely(x == ECL_UNBOUND))
 		cl_error(5, @'unbound-slot', @':name', index, @':instance', x);
@@ -130,9 +134,11 @@
 
 	if (ecl_unlikely(!ECL_INSTANCEP(x)))
                 FEwrong_type_nth_arg(@[si::instance-set], 1, x, @[ext::instance]);
-	if (ecl_unlikely(!FIXNUMP(index) ||
-                         (i = fix(index)) >= (cl_fixnum)x->instance.length || i < 0))
-		FEtype_error_index(x, index);
+	if (ecl_unlikely(!FIXNUMP(index)))
+		FEwrong_type_nth_arg(@[si::instance-set], 2, index, @[fixnum]);
+	i = fix(index);
+	if (ecl_unlikely(i < 0 || i >= (cl_fixnum)x->instance.length))
+		FEtype_error_index(x, i);
 	x->instance.slots[i] = value;
 	@(return value)
 }
@@ -164,9 +170,11 @@
 
 	if (ecl_unlikely(!ECL_INSTANCEP(x)))
                 FEwrong_type_nth_arg(@[si::sl-makunbound], 1, x, @[ext::instance]);
-	if (ecl_unlikely(!FIXNUMP(index) ||
-                         (i = fix(index)) >= x->instance.length || i < 0))
-		FEtype_error_index(x, index);
+	if (ecl_unlikely(!FIXNUMP(index)))
+		FEwrong_type_nth_arg(@[si::sl-makunbound], 2, index, @[fixnum]);
+	i = fix(index);
+	if (ecl_unlikely(i < 0 || i >= x->instance.length))
+		FEtype_error_index(x, i);
 	x->instance.slots[i] = ECL_UNBOUND;
 	@(return x)
 }
--- ./src/c/array.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/array.d	2012-02-04 21:28:54.730337056 -0700
@@ -48,8 +48,6 @@
         @'base-char'          /* aet_bc */
 };
 
-static void check_displaced (cl_object dlist, cl_object orig, cl_index newdim);
-
 static void FEbad_aet() ecl_attr_noreturn;
 
 static void
@@ -99,13 +97,11 @@
 	case t_fixnum: {
 		cl_fixnum out = fix(n);
 		if (out < 0 || out >= ADIMLIM)
-			FEtype_error_index(Cnil, n);
+			FEtype_error_index(Cnil, out);
 		return out;
 	}
-	case t_bignum:
-		FEtype_error_index(Cnil, n);
 	default:
-                FEwrong_type_only_arg(@[coerce], n, @[integer]);
+                FEwrong_type_only_arg(@[coerce], n, @[fixnum]);
 	}
 }
 
@@ -236,7 +232,7 @@
 void *
 ecl_row_major_ptr(cl_object x, cl_index index, cl_index bytes)
 {
-	cl_index idx, elt_size, offset;
+	cl_index elt_size, offset;
 	cl_elttype elt_type;
 
 	if (ecl_unlikely(!ECL_ARRAYP(x))) {
@@ -540,7 +536,7 @@
 ecl_array_allocself(cl_object x)
 {
         cl_elttype t = x->array.elttype;
-	cl_index i, d = x->array.dim;
+	cl_index d = x->array.dim;
 	switch (t) {
 	/* assign self field only after it has been filled, for GC sake  */
 	case aet_object:
@@ -913,7 +909,6 @@
 cl_object
 cl_array_displacement(cl_object a)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	cl_object to_array;
 	cl_index offset;
 
@@ -986,7 +981,6 @@
 cl_object
 cl_svref(cl_object x, cl_object index)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	cl_index i;
 
 	if (ecl_unlikely(type_of(x) != t_vector ||
@@ -1003,7 +997,6 @@
 cl_object
 si_svset(cl_object x, cl_object index, cl_object v)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	cl_index i;
 
 	if (ecl_unlikely(type_of(x) != t_vector ||
@@ -1020,7 +1013,6 @@
 cl_object
 cl_array_has_fill_pointer_p(cl_object a)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	cl_object r;
 	switch (type_of(a)) {
 	case t_array:
@@ -1042,7 +1034,6 @@
 cl_object
 cl_fill_pointer(cl_object a)
 {
-	const cl_env_ptr the_env = ecl_process_env();
         if (ecl_unlikely(!ECL_VECTORP(a)))
                 FEwrong_type_only_arg(@[fill-pointer], a, @[vector]);
 	if (ecl_unlikely(!ECL_ARRAY_HAS_FILL_POINTER_P(a))) {
@@ -1058,7 +1049,6 @@
 cl_object
 si_fill_pointer_set(cl_object a, cl_object fp)
 {
-	const cl_env_ptr the_env = ecl_process_env();
         cl_fixnum i;
         if (ecl_unlikely(!ECL_VECTORP(a) || !ECL_ARRAY_HAS_FILL_POINTER_P(a))) {
                 const char *type = "(AND VECTOR (SATISFIES ARRAY-HAS-FILL-POINTER-P))";
@@ -1085,7 +1075,6 @@
 cl_object
 si_replace_array(cl_object olda, cl_object newa)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	cl_object dlist;
 	if (type_of(olda) != type_of(newa)
 	    || (type_of(olda) == t_array && olda->array.rank != newa->array.rank))
--- ./src/c/compiler.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/compiler.d	2012-02-04 21:28:54.731337035 -0700
@@ -2419,7 +2419,7 @@
         cl_index *bytecodes = ecl_alloc_atomic((l + 1) * sizeof(cl_index));
         cl_index *p = bytecodes;
         for (*(p++) = l; end > start; end--, p++) {
-                *p = ECL_STACK_POP_UNSAFE(env);
+                *p = (cl_index)ECL_STACK_POP_UNSAFE(env);
         }
         return bytecodes;
 #else
@@ -2433,7 +2433,7 @@
         cl_index *p = bytecodes;
         cl_index l;
         for (l = *p; l; l--) {
-                ECL_STACK_PUSH(env, p[l]);
+                ECL_STACK_PUSH(env, (cl_object)p[l]);
         }
         ecl_dealloc(bytecodes);
 }
@@ -2716,7 +2716,6 @@
 	if (context == @'function') { \
 		unlikely_if (ecl_symbol_type(v) & stp_constant)	\
 			FEillegal_variable_name(v); }
-	const cl_env_ptr the_env = ecl_process_env();
         cl_object lists[4] = {Cnil, Cnil, Cnil, Cnil};
         cl_object *reqs = lists, *opts = lists+1, *keys = lists+2, *auxs = lists+3;
 	cl_object v, rest = Cnil, lambda_list = org_lambda_list;
@@ -3075,7 +3074,7 @@
 cl_object
 si_make_lambda(cl_object name, cl_object rest)
 {
-	cl_object lambda;
+	cl_object lambda = Cnil;
         const cl_env_ptr the_env = ecl_process_env();
 	volatile cl_compiler_env_ptr old_c_env = the_env->c_env;
 	struct cl_compiler_env new_c_env;
--- ./src/c/stacks.d.orig	2012-02-04 16:02:23.000000000 -0700
+++ ./src/c/stacks.d	2012-02-04 21:28:54.732337014 -0700
@@ -278,8 +278,6 @@
 static cl_index
 invalid_or_too_large_binding_index(cl_env_ptr env, cl_object s)
 {
-        cl_object *location;
-        struct bds_bd *slot;
         cl_index index = s->symbol.binding;
         if (index == ECL_MISSING_SPECIAL_BINDING) {
                 index = ecl_new_binding_index(env, s);
--- ./src/c/file.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/file.d	2012-02-04 21:28:54.733336993 -0700
@@ -1093,7 +1093,7 @@
 {
 	int nbytes;
 	if (c < 0) {
-		return 0;
+		nbytes = 0;
 	} else if (c <= 0x7F) {
 		buffer[0] = c;
 		nbytes = 1;
@@ -1113,6 +1113,8 @@
 		buffer[1] = (c & 0x3f) | 0x80; c >>= 6;
 		buffer[0] = c | 0xF0;
 		nbytes = 4;
+	} else {
+		nbytes = 0;
 	}
 	return nbytes;
 }
@@ -4913,7 +4915,7 @@
 		case smm_input: fp = safe_fopen(fname, OPEN_R); break;
 		case smm_output:
 		case smm_io: fp = safe_fopen(fname, OPEN_RW); break;
-                default:; /* never reached */
+                default: fp = NULL; /* never reached */
 		}
 		output = ecl_make_stream_from_FILE(fn, fp, smm, byte_size, flags,
 						   external_format);
@@ -5008,7 +5010,7 @@
 #if !defined(ECL_MS_WINDOWS_HOST)
 # if defined(HAVE_SELECT)
 	fd_set fds;
-	int retv, fd;
+	int retv;
 	struct timeval tv = { 0, 0 };
         /*
          * Note that the following code is fragile. If the file is closed (/dev/null)
--- ./src/c/ffi/cdata.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/ffi/cdata.d	2012-02-04 21:28:54.734336972 -0700
@@ -13,6 +13,7 @@
     See file '../Copyright' for full details.
 */
 
+#include <string.h>
 #include <ecl/ecl.h>
 #include <ecl/ecl-inl.h>
 
--- ./src/c/ffi/mmap.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/ffi/mmap.d	2012-02-04 21:28:54.734336972 -0700
@@ -61,6 +61,8 @@
                 fd = ecl_to_int(si_file_stream_fd(stream));
                 if (Null(length))
                         len = ecl_to_unsigned_integer(ecl_file_length(stream));
+		else
+			len = ecl_to_unsigned_integer(length);
         }
         output = si_make_vector(element_type, MAKE_FIXNUM(0), Cnil,
                                 Cnil, Cnil, Cnil);
--- ./src/c/ffi/libraries.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/ffi/libraries.d	2012-02-04 21:28:54.735336951 -0700
@@ -217,7 +217,7 @@
 ecl_library_open_inner(cl_object filename, bool self_destruct)
 {
         const cl_env_ptr the_env = ecl_process_env();
-	cl_object other, block = ecl_alloc_object(t_codeblock);
+	cl_object block = ecl_alloc_object(t_codeblock);
 	block->cblock.self_destruct = self_destruct;
 	block->cblock.locked = 0;
 	block->cblock.handle = NULL;
@@ -263,7 +263,6 @@
 ecl_library_open(cl_object filename, bool force_reload) {
 	cl_object block;
 	bool self_destruct = 0;
-	char *filename_string;
 
 	/* Coerces to a file name but does not merge with cwd */
 	filename = coerce_to_physical_pathname(filename);
@@ -435,7 +434,6 @@
                 ecl_enable_interrupts();
         } ECL_WITH_GLOBAL_LOCK_END;
 	if (block != Cnil && block->cblock.self_destruct) {
-                const char *filename;
                 if (!Null(block->cblock.name)) {
                         unlink((char*)block->cblock.name->base_string.self);
                 }
--- ./src/c/number.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/number.d	2012-02-04 21:28:54.736336930 -0700
@@ -96,7 +96,6 @@
 
 ecl_uint8_t
 ecl_to_uint8_t(cl_object x) {
-	cl_fixnum aux;
 	if (ecl_likely(ECL_FIXNUMP(x))) {
 		cl_fixnum aux = ecl_fix(x);
 		if (ecl_likely(aux >= 0 && aux <= 255))
@@ -108,7 +107,6 @@
 
 ecl_int8_t
 ecl_to_int8_t(cl_object x) {
-	cl_fixnum aux;
 	if (ecl_likely(ECL_FIXNUMP(x))) {
 		cl_fixnum aux = ecl_fix(x);
 		if (ecl_likely(aux >= -128 && aux <= 127))
--- ./src/c/interpreter.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/interpreter.d	2012-02-04 21:28:54.736336930 -0700
@@ -271,7 +271,7 @@
         volatile cl_index frame_index = 0;
 	cl_opcode *vector = (cl_opcode*)bytecodes->bytecodes.code;
 	cl_object *data = bytecodes->bytecodes.data;
-	cl_object reg0, reg1, lex_env = env;
+	cl_object reg0 = OBJNULL, reg1 = OBJNULL, lex_env = env;
 	cl_index narg;
 	struct ecl_stack_frame frame_aux;
 	volatile struct ihs_frame ihs;
@@ -284,7 +284,6 @@
 	frame_aux.stack = frame_aux.base = 0;
         frame_aux.size = 0;
         frame_aux.env = the_env;
- BEGIN:
 	BEGIN_SWITCH {
 	CASE(OP_NOP); {
 		reg0 = Cnil;
--- ./src/c/read.d.orig	2012-02-04 16:02:23.000000000 -0700
+++ ./src/c/read.d	2012-02-04 21:28:54.737336909 -0700
@@ -880,6 +880,7 @@
 	}
 	if (Null(d)) {
 		dim = dimcount;
+		last = OBJNULL;
 	} else {
                 unlikely_if (!ECL_FIXNUMP(d) || ((dim = fix(d)) < 0) ||
                              (dim > ADIMLIM))
@@ -910,7 +911,6 @@
 {
 	cl_object rtbl = ecl_current_readtable();
 	enum ecl_chattrib a;
-	bool escape_flag;
 	int c;
 	cl_object output, token;
 
@@ -918,7 +918,6 @@
 		extra_argument(':', in, d);
 	c = ecl_read_char_noeof(in);
 	a = ecl_readtable_get(rtbl, c, NULL);
-	escape_flag = FALSE;
 	token = si_get_buffer_string();
 	goto L;
 	for (;;) {
@@ -932,9 +931,7 @@
 		if (a == cat_single_escape) {
 			c = ecl_read_char_noeof(in);
 			a = cat_constituent;
-			escape_flag = TRUE;
 		} else if (a == cat_multiple_escape) {
-			escape_flag = TRUE;
 			for (;;) {
 				c = ecl_read_char_noeof(in);
 				a = ecl_readtable_get(rtbl, c, NULL);
@@ -1055,7 +1052,7 @@
 sharp_eq_reader(cl_object in, cl_object c, cl_object d)
 {
 	const cl_env_ptr the_env = ecl_process_env();
-	cl_object definition, pair, value;
+	cl_object pair, value;
 	cl_object sharp_eq_context = ECL_SYM_VAL(the_env, @'si::*sharp-eq-context*');
 
 	if (read_suppress) @(return);
@@ -1727,10 +1724,6 @@
 	@(return (ECL_READTABLEP(readtable) ? Ct : Cnil))
 }
 
-#ifdef ECL_UNICODE
-static struct ecl_readtable_entry default_readtable_entry;
-#endif
-
 int
 ecl_readtable_get(cl_object readtable, int c, cl_object *macro_or_table)
 {
@@ -2172,7 +2165,7 @@
 	volatile cl_object x;
 	cl_index i, len, perm_len, temp_len;
 	cl_object in;
-	cl_object *VV, *VVtemp = 0;
+	cl_object *VV = 0, *VVtemp = 0;
 
 	if (block == NULL)
                 block = ecl_make_codeblock();
@@ -2276,7 +2269,6 @@
 			cl_index fname_location = fix(prototype->block);
 			cl_object fname = VV[fname_location];
 			cl_index location = fix(prototype->name);
-                        cl_object source = prototype->file;
                         cl_object position = prototype->file_position;
 			int narg = prototype->narg;
 			VV[location] = narg<0?
--- ./src/c/clos/cache.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/clos/cache.d	2012-02-04 21:28:54.738336888 -0700
@@ -82,7 +82,6 @@
 ecl_make_cache(cl_index key_size, cl_index cache_size)
 {
 	ecl_cache_ptr cache = ecl_alloc(sizeof(struct ecl_cache));
-	cl_object table;
 	cache->keys =
 		si_make_vector(Ct, /* element type */
 			       MAKE_FIXNUM(key_size), /* Maximum size */
--- ./src/c/predicate.d.orig	2012-02-04 16:02:23.000000000 -0700
+++ ./src/c/predicate.d	2012-02-04 21:28:54.738336888 -0700
@@ -269,7 +269,6 @@
 bool
 ecl_eql(cl_object x, cl_object y)
 {
-	cl_type t;
 	if (x == y)
 		return TRUE;
         if (IMMEDIATE(x) || IMMEDIATE(y))
@@ -508,7 +507,6 @@
 					return TRUE;
 				} else {
 					cl_object key = env->values[1];
-					cl_object value = env->values[2];
 					if (ecl_gethash_safe(key, y, OBJNULL) == OBJNULL)
 						return FALSE;
 				}
--- ./src/c/numbers/number_compare.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/numbers/number_compare.d	2012-02-04 21:28:54.739336867 -0700
@@ -136,7 +136,6 @@
 		default:
 			FEwrong_type_nth_arg(@[<], 2, y, @[real]);
 		}
-	DOUBLEFLOAT:
 		if (dx == dy)
 			return(0);
 		else if (dx < dy)
--- ./src/c/numbers/expt.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/numbers/expt.d	2012-02-04 21:28:54.739336867 -0700
@@ -81,7 +81,7 @@
                 return ecl_make_complex(z, MAKE_FIXNUM(0));
         default:
                 /* We will never reach this */
-                (void)0;
+                return OBJNULL;
         }
 }
 
--- ./src/c/main.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/main.d	2012-02-04 21:28:54.740336846 -0700
@@ -40,6 +40,7 @@
 #endif
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <ecl/cache.h>
 #include <ecl/internal.h>
 #include <ecl/ecl-inl.h>
@@ -791,7 +792,6 @@
 cl_object
 si_setenv(cl_object var, cl_object value)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	cl_fixnum ret_val;
 
 	/* Strings have to be null terminated base strings */
@@ -856,7 +856,6 @@
 cl_object
 si_pointer(cl_object x)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	@(return ecl_make_unsigned_integer((cl_index)x))
 }
 
--- ./src/c/cfun_dispatch.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/cfun_dispatch.d	2012-02-04 21:28:54.740336846 -0700
@@ -451,13 +451,6 @@
   return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62);
 }
 
-static cl_object dispatch64 (cl_narg narg, cl_object x0, cl_object x1, cl_object x2, cl_object x3, cl_object x4, cl_object x5, cl_object x6, cl_object x7, cl_object x8, cl_object x9, cl_object x10, cl_object x11, cl_object x12, cl_object x13, cl_object x14, cl_object x15, cl_object x16, cl_object x17, cl_object x18, cl_object x19, cl_object x20, cl_object x21, cl_object x22, cl_object x23, cl_object x24, cl_object x25, cl_object x26, cl_object x27, cl_object x28, cl_object x29, cl_object x30, cl_object x31, cl_object x32, cl_object x33, cl_object x34, cl_object x35, cl_object x36, cl_object x37, cl_object x38, cl_object x39, cl_object x40, cl_object x41, cl_object x42, cl_object x43, cl_object x44, cl_object x45, cl_object x46, cl_object x47, cl_object x48, cl_object x49, cl_object x50, cl_object x51, cl_object x52, cl_object x53, cl_object x54, cl_object x55, cl_object x56, cl_object x57, cl_object x58, cl_object x59, cl_object x60, cl_object x61, cl_object x62, cl_object x63) {
-  const cl_env_ptr the_env = ecl_process_env();
-  cl_object fun = the_env->function;
-  if (ecl_unlikely(narg != 64)) FEwrong_num_arguments(fun);
-  return fun->cfunfixed.entry_fixed(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, x45, x46, x47, x48, x49, x50, x51, x52, x53, x54, x55, x56, x57, x58, x59, x60, x61, x62, x63);
-}
-
 static cl_objectfn dispatch_table[64] = {
 (cl_objectfn)dispatch0, 
 (cl_objectfn)dispatch1, 
--- ./src/c/disassembler.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/disassembler.d	2012-02-04 21:28:54.741336825 -0700
@@ -667,7 +667,7 @@
                 unlikely_if (!ECL_VECTORP(code) ||
                              (data->vector.elttype != aet_object)) {
                         FEwrong_type_nth_arg(@[si::bc-join],
-                                             0, output,
+                                             0, code,
                                              cl_list(2,
                                                      @'simple-array',
                                                      Ct));
--- ./src/c/symbol.d.orig	2012-02-04 16:02:23.000000000 -0700
+++ ./src/c/symbol.d	2012-02-04 21:28:54.741336825 -0700
@@ -281,7 +281,6 @@
 cl_object
 cl_get_properties(cl_object place, cl_object indicator_list)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	cl_object l;
 
 #ifdef ECL_SAFE
@@ -404,7 +403,6 @@
 cl_object
 si_rem_f(cl_object plist, cl_object indicator)
 {
-	cl_env_ptr the_env = ecl_process_env();
 	bool found = remf(&plist, indicator);
 	@(return plist (found? Ct : Cnil))
 }
--- ./src/c/package.d.orig	2012-02-04 16:02:22.000000000 -0700
+++ ./src/c/package.d	2012-02-04 21:28:54.742336804 -0700
@@ -194,7 +194,7 @@
 ecl_make_package(cl_object name, cl_object nicknames, cl_object use_list)
 {
         const cl_env_ptr env = ecl_process_env();
-	cl_object x, l, other = Cnil;
+	cl_object x, other = Cnil;
 
         /* Type checking, coercions, and the like, happen before we
          * acquire the lock */
@@ -357,7 +357,7 @@
 cl_object
 ecl_intern(cl_object name, cl_object p, int *intern_flag)
 {
-	cl_object s, ul;
+	cl_object s;
         bool error, ignore_error = 0;
 
         if (ecl_unlikely(!ECL_STRINGP(name)))
@@ -466,7 +466,7 @@
 bool
 ecl_unintern(cl_object s, cl_object p)
 {
-	cl_object conflict, l, hash;
+	cl_object conflict;
 	bool output = FALSE;
 	cl_object name = ecl_symbol_name(s);
 
@@ -527,7 +527,6 @@
 void
 cl_export2(cl_object s, cl_object p)
 {
-	cl_object x, l, hash = OBJNULL;
 	int intern_flag, error;
 	cl_object other_p, name = ecl_symbol_name(s);
 	p = si_coerce_to_package(p);
@@ -1037,7 +1036,6 @@
 
 @(defun use_package (pack &o (pa ecl_current_package()))
 @
-BEGIN:
 	switch (type_of(pack)) {
 	case t_symbol:
 	case t_character:
@@ -1060,7 +1058,6 @@
 
 @(defun unuse_package (pack &o (pa ecl_current_package()))
 @
-BEGIN:
 	switch (type_of(pack)) {
 	case t_symbol:
 	case t_character:
--- ./src/c/printer/write_ugly.d.orig	2012-02-04 16:02:23.000000000 -0700
+++ ./src/c/printer/write_ugly.d	2012-02-04 21:28:54.742336804 -0700
@@ -463,7 +463,6 @@
 cl_object
 si_write_ugly_object(cl_object x, cl_object stream)
 {
-        int t;
 	if (x == OBJNULL) {
 		if (ecl_print_readably())
                         FEprint_not_readable(x);
--- ./src/c/printer/float_to_digits.d.orig	2012-02-04 16:02:23.000000000 -0700
+++ ./src/c/printer/float_to_digits.d	2012-02-04 21:28:54.743336783 -0700
@@ -177,7 +177,6 @@
                 {
                         cl_object e1 = cl_expt(PRINT_BASE, position);
                         cl_object e2 = ecl_divide(e1, MAKE_FIXNUM(2));
-                        cl_object e3 = cl_expt(PRINT_BASE, k); 
                         if (ecl_greatereq(ecl_plus(approx->r, ecl_times(approx->s, e1)),
                                           ecl_times(approx->s, e2)))
                                 position = ecl_one_minus(position);
--- ./src/c/reference.d.orig	2012-02-04 16:02:23.000000000 -0700
+++ ./src/c/reference.d	2012-02-04 21:28:54.743336783 -0700
@@ -169,7 +169,6 @@
 cl_object
 cl_special_operator_p(cl_object form)
 {
-	const cl_env_ptr the_env = ecl_process_env();
 	int special = ecl_symbol_type(form) & stp_special_form;
 	@(return (special? Ct : Cnil))
 }
