--- ./src/c/ffi.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/ffi.d	2012-08-08 13:11:51.158046473 -0600
@@ -701,7 +701,7 @@ si_load_foreign_module(cl_object filenam
 #if !defined(ENABLE_DLOPEN)
 	FEerror("SI:LOAD-FOREIGN-MODULE does not work when ECL is statically linked", 0);
 #else
-	cl_object output;
+	cl_object output = ECL_NIL;
 
 # ifdef ECL_THREADS
 	mp_get_lock(1, ecl_symbol_value(@'mp::+load-compile-lock+'));
--- ./src/c/cinit.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/cinit.d	2012-08-08 13:09:32.569613012 -0600
@@ -146,6 +146,7 @@ static cl_object si_simple_toplevel ()
                         ecl_prin1(sentence, output);
                 }
         } ECL_CATCH_ALL_END;
+	return ECL_NIL;
 }
 
 int
--- ./src/c/read.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/read.d	2012-08-08 13:09:32.570613009 -0600
@@ -2261,7 +2261,7 @@ ecl_init_module(cl_object block, void (*
 	volatile cl_object x;
 	cl_index i, len, perm_len, temp_len;
 	cl_object in;
-	cl_object *VV, *VVtemp = 0;
+	cl_object *VV = 0, *VVtemp = 0;
 
 	if (block == NULL)
                 block = ecl_make_codeblock();
--- ./src/c/compiler.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/compiler.d	2012-08-08 13:09:32.572613002 -0600
@@ -3073,7 +3073,7 @@ si_valid_function_name_p(cl_object name)
 cl_object
 si_make_lambda(cl_object name, cl_object rest)
 {
-	cl_object lambda;
+	cl_object lambda = Cnil;
         const cl_env_ptr the_env = ecl_process_env();
 	volatile cl_compiler_env_ptr old_c_env = the_env->c_env;
 	struct cl_compiler_env new_c_env;
--- ./src/c/unixfsys.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/unixfsys.d	2012-08-08 13:09:32.573612999 -0600
@@ -460,7 +460,6 @@ ecl_file_len(int f)
 
 @(defun rename-file (oldn newn &key (if_exists @':error'))
 	cl_object old_filename, new_filename, old_truename, new_truename;
-	int error;
 @
 
 	/* 1) Get the old filename, and complain if it has wild components,
@@ -497,6 +496,9 @@ ecl_file_len(int f)
                         1, if_exists);
 	}
         {
+#if defined(ECL_MS_WINDOWS_HOST)
+		int error;
+#endif
                 ecl_disable_interrupts();
 #if defined(ECL_MS_WINDOWS_HOST)
 		error = SetErrorMode(0);
@@ -630,7 +632,10 @@ ecl_homedir_pathname(cl_object user)
 {
 	cl_index i;
 	cl_object namestring;
-	const char *h, *d;
+	const char *h;
+#if defined(ECL_MS_WINDOWS_HOST)
+	const char *d;
+#endif
 	if (!Null(user)) {
 #ifdef HAVE_PWD_H
 		struct passwd *pwent = NULL;
--- ./src/c/hash.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/hash.d	2012-08-08 13:09:32.574612996 -0600
@@ -46,7 +46,7 @@ _hash_eql(cl_hashkey h, cl_object x)
 		h = _hash_eql(h, x->ratio.num);
 		return _hash_eql(h, x->ratio.den);
 	case t_singlefloat:
-		return hash_string(h, (unsigned char*)&ecl_single_float(x), sizeof(ecl_signle_float(x)));
+		return hash_string(h, (unsigned char*)&ecl_single_float(x), sizeof(ecl_single_float(x)));
 	case t_doublefloat:
 		return hash_string(h, (unsigned char*)&ecl_double_float(x), sizeof(ecl_double_float(x)));
 #ifdef ECL_LONG_FLOAT
--- ./src/c/printer/float_to_digits.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/printer/float_to_digits.d	2012-08-08 13:09:32.574612996 -0600
@@ -177,7 +177,6 @@ change_precision(float_approx *approx, c
                 {
                         cl_object e1 = cl_expt(PRINT_BASE, position);
                         cl_object e2 = ecl_divide(e1, ecl_make_fixnum(2));
-                        cl_object e3 = cl_expt(PRINT_BASE, k); 
                         if (ecl_greatereq(ecl_plus(approx->r, ecl_times(approx->s, e1)),
                                           ecl_times(approx->s, e2)))
                                 position = ecl_one_minus(position);
--- ./src/c/num_co.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/num_co.d	2012-08-08 13:09:32.575612992 -0600
@@ -453,7 +453,7 @@ ecl_ceiling2(cl_object x, cl_object y)
 		}
 #endif
 		default:
-		  (void)0; /*Never reached */
+		  __builtin_unreachable(); /*Never reached */
 		}
 		break;
 	case t_bignum:
@@ -499,7 +499,7 @@ ecl_ceiling2(cl_object x, cl_object y)
 		}
 #endif
 		default:
-		  (void)0; /*Never reached */
+		  __builtin_unreachable(); /*Never reached */
 		}
 		break;
 	case t_ratio:
--- ./src/c/ffi/libraries.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/ffi/libraries.d	2012-08-08 13:09:32.575612992 -0600
@@ -299,7 +299,6 @@ cl_object
 ecl_library_open(cl_object filename, bool force_reload) {
 	cl_object block;
 	bool self_destruct = 0;
-	char *filename_string;
 
 	/* Coerces to a file name but does not merge with cwd */
 	filename = coerce_to_physical_pathname(filename);
--- ./src/c/unixint.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/unixint.d	2012-08-08 13:09:32.576612988 -0600
@@ -534,6 +534,8 @@ asynchronous_signal_servicing_thread()
 			interrupt_signal =
 				ecl_option_values[ECL_OPT_THREAD_INTERRUPT_SIGNAL];
 			sigdelset(&handled_set, interrupt_signal);
+		} else {
+			interrupt_signal = -1;
 		}
 		pthread_sigmask(SIG_BLOCK, &handled_set, NULL);
 	}
@@ -608,7 +610,7 @@ static void
 handler_fn_prototype(fpe_signal_handler, int sig, siginfo_t *info, void *data)
 {
 	cl_object condition;
-        int code, old_errno = errno;
+        int code;
 	cl_env_ptr the_env;
 	reinstall_signal(sig, fpe_signal_handler);
         /* The lisp environment might not be installed. */
@@ -783,7 +785,6 @@ ecl_check_pending_interrupts(cl_env_ptr
 static cl_object
 do_catch_signal(int code, cl_object action, cl_object process)
 {
-	cl_object code_fixnum = ecl_make_fixnum(code);
         if (action == ECL_NIL || action == @':ignore') {
                 mysignal(code, SIG_IGN);
                 return ECL_T;
--- ./src/c/num_log.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/num_log.d	2012-08-08 13:09:32.577612985 -0600
@@ -476,7 +476,7 @@ cl_object
 si_bit_array_op(cl_object o, cl_object x, cl_object y, cl_object r)
 {
 	cl_fixnum i, j, n, d;
-	cl_object r0;
+	cl_object r0 = ECL_NIL;
 	bit_operator op;
 	bool replace = FALSE;
 	int xi, yi, ri;
--- ./src/c/numbers/expt.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/numbers/expt.d	2012-08-08 13:09:32.577612985 -0600
@@ -81,7 +81,7 @@ expt_zero(cl_object x, cl_object y)
                 return ecl_make_complex(z, ecl_make_fixnum(0));
         default:
                 /* We will never reach this */
-                (void)0;
+                __builtin_unreachable();
         }
 }
 
--- ./src/c/alloc_2.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/alloc_2.d	2012-08-08 13:09:32.578612982 -0600
@@ -33,6 +33,9 @@
 
 static void gather_statistics();
 static void ecl_mark_env(struct cl_env_struct *env);
+extern void GC_push_all(char *bottom, char *top);
+extern void GC_push_conditional(char *bottom, char *top, int all);
+extern void GC_set_mark_bit(const void *p);
 
 #ifdef GBC_BOEHM_PRECISE
 # if GBC_BOEHM
@@ -760,8 +763,6 @@ to_bitmap(void *x, void *y)
 void
 init_alloc(void)
 {
-        union cl_lispunion o;
-        struct ecl_cons c;
 	int i;
 	if (alloc_initialized) return;
 	alloc_initialized = TRUE;
--- ./src/c/interpreter.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/interpreter.d	2012-08-08 13:09:32.579612979 -0600
@@ -273,7 +273,7 @@ ecl_interpret(cl_object frame, cl_object
         volatile cl_index frame_index = 0;
 	cl_opcode *vector = (cl_opcode*)bytecodes->bytecodes.code;
 	cl_object *data = bytecodes->bytecodes.data->vector.self.t;
-	cl_object reg0, reg1, lex_env = env;
+	cl_object reg0 = OBJNULL, reg1 = OBJNULL, lex_env = env;
 	cl_index narg;
 	struct ecl_stack_frame frame_aux;
 	volatile struct ecl_ihs_frame ihs;
--- ./src/c/file.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/file.d	2012-08-08 13:09:32.581612973 -0600
@@ -1119,6 +1119,8 @@ utf_8_encoder(cl_object stream, unsigned
 		buffer[1] = (c & 0x3f) | 0x80; c >>= 6;
 		buffer[0] = c | 0xF0;
 		nbytes = 4;
+	} else {
+		nbytes = 0;
 	}
 	return nbytes;
 }
@@ -5110,7 +5112,7 @@ ecl_open_stream(cl_object fn, enum ecl_s
 		FEerror("Illegal stream mode ~S", 1, ecl_make_fixnum(smm));
 	}
 	if (flags & ECL_STREAM_C_STREAM) {
-		FILE *fp;
+		FILE *fp = NULL;
 		safe_close(f);
 		/* We do not use fdopen() because Windows seems to
 		 * have problems with the resulting streams. Furthermore, even for
--- ./src/c/serialize.d.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/c/serialize.d	2012-08-08 13:09:32.581612973 -0600
@@ -120,7 +120,7 @@ fix_to_ptr(cl_object ptr)
 static cl_object
 enqueue(pool_t pool, cl_object what)
 {
-        cl_object record, index;
+        cl_object index;
         if (ECL_FIXNUMP(what) || ECL_CHARACTERP(what) || what == OBJNULL) {
                 return what;
         }
--- ./src/h/legacy.h.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/h/legacy.h	2012-08-08 13:13:29.205633962 -0600
@@ -120,7 +120,7 @@
 
 #define number_to_float(x) ((float)ecl_to_double(x))
 
-#define ecl_make_unsigned_long_Long(o) ecl_make_ulong_long(o)
+#define ecl_make_unsigned_long_Long(o) ecl_make_ulong_Long(o)
 #define ecl_to_unsigned_long_long(o) ecl_to_ulong_long(o)
 
 #define ADIMLIM ECL_ARRAY_DIMENSION_LIMIT
--- ./src/h/ecl-inl.h.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/h/ecl-inl.h	2012-08-08 13:09:32.582612969 -0600
@@ -73,11 +73,11 @@
                 cl_fixnum padding[(sizeof(struct ecl_base_string)+3)/4*4]; \
         } name[]
 
-#define ecl_def_string_array_elt(chars) {                      \
+#define ecl_def_string_array_elt(chars) { {                      \
                 (int8_t)t_base_string, 0, ecl_aet_bc, 0,            \
                         ECL_NIL, (cl_index)(sizeof(chars))-1,      \
                         (cl_index)(sizeof(chars))-1,            \
-                        (ecl_base_char*)(chars) }
+                        (ecl_base_char*)(chars) } }
 
 #define ecl_def_ct_base_string(name,chars,len,static,const)     \
         static const struct ecl_base_string name ## _data = {    \
--- ./src/h/external.h.orig	2012-07-24 10:51:53.000000000 -0600
+++ ./src/h/external.h	2012-08-08 13:13:14.485702638 -0600
@@ -1101,7 +1101,7 @@ extern ECL_API cl_object ecl_make_int64_
 #ifdef ecl_long_long_t
 extern ECL_API ecl_ulong_long_t ecl_to_ulong_Long(cl_object p);
 extern ECL_API ecl_long_long_t ecl_to_long_long(cl_object p);
-extern ECL_API cl_object ecl_make_ulong_long(ecl_ulong_long_t i);
+extern ECL_API cl_object ecl_make_ulong_Long(ecl_ulong_long_t i);
 extern ECL_API cl_object ecl_make_long_long(ecl_long_long_t i);
 #endif /* ecl_long_long_t */
 
